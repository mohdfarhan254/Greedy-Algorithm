
class Solution {

    public ArrayList<Integer> JobSequencing(int[] id, int[] deadline, int[] profit) {
        // code here..
       /*
   ‚úÖ **Problem Statement:**
   - Given `N` jobs, each with a **deadline** and **profit**.
   - We can schedule **only one job per time slot**.
   - Each job must be completed **before or on its deadline**.
   - The goal is to **schedule jobs** in a way that **maximizes the total profit**.

   ‚úÖ **Approach:**
   1Ô∏è‚É£ **Store Jobs as {profit, deadline}** ‚Üí To easily access job data.
   2Ô∏è‚É£ **Find Maximum Deadline** ‚Üí This determines the maximum possible time slots.
   3Ô∏è‚É£ **Sort Jobs by Profit (Descending Order)** ‚Üí Prioritize high-profit jobs.
   4Ô∏è‚É£ **Greedy Scheduling:**
       - Assign each job to the **latest available slot** before its deadline.
       - If a slot is free, schedule the job and add its profit.
   5Ô∏è‚É£ **Return the total profit and number of scheduled jobs.**
*/

/*
   ‚úÖ **Time Complexity Analysis**
   1Ô∏è‚É£ **Finding Maximum Deadline** ‚Üí O(N)  
      - We iterate through `deadline[]` to find the maximum deadline.

   2Ô∏è‚É£ **Sorting Jobs by Profit** ‚Üí O(N log N)  
      - Sorting the list of jobs based on profit in descending order.

   3Ô∏è‚É£ **Scheduling Jobs Greedily** ‚Üí O(N * D)  
      - For each job, we check at most `D` slots in the `availableSlots[]` array.
      - In the worst case, `D` could be `N`, leading to O(N * N) complexity.
      - However, **D is usually small** in real-world cases, making this closer to O(N log N).

   ‚û° **Overall Complexity: O(N log N) + O(N * D)**
   - If `D` is small, it approximates **O(N log N)**.
   - In the worst case, it is **O(N¬≤)** (if `D ‚âà N`).

   ‚úÖ **Space Complexity Analysis**
   1Ô∏è‚É£ **Job List (jobs ArrayList)** ‚Üí O(N)  
      - Stores `{profit, deadline}` pairs for `N` jobs.

   2Ô∏è‚É£ **Slot Array (availableSlots[])** ‚Üí O(D)  
      - Boolean array of size `maxDeadline + 1`.

   ‚û° **Overall Space Complexity: O(N + D)**  
   - Typically, `D` is much smaller than `N`, so it is close to **O(N)** in practice.
*/


        int n = deadline.length;
        
        /* ‚úÖ Step 1: Store Jobs as {profit, deadline} and find maxDeadline */
        int maxDeadline = 0;
        ArrayList<int[]> jobs = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            jobs.add(new int[]{profit[i], deadline[i]});
            maxDeadline = Math.max(maxDeadline, deadline[i]);  // Track max deadline
        }
        
        /* ‚úÖ Step 2: Sort Jobs by Profit in Descending Order */
        jobs.sort((a, b) -> Integer.compare(b[0], a[0]));  
        
        /* ‚úÖ Step 3: Create Slot Array to Track Job Placement */
        boolean[] availableSlots = new boolean[maxDeadline + 1];  
        int maxProfit = 0, count = 0;  // Stores total profit & count of scheduled jobs
        
        /* ‚úÖ Step 4: Assign Jobs to the Latest Possible Slot Before Their Deadline */
        for (int[] job : jobs) {
            int p = job[0];  // Profit of current job
            int d = job[1];  // Deadline of current job
            
            /* üîπ Find the latest available slot before or on the deadline */
            for (int j = d; j > 0; j--) {
                if (!availableSlots[j]) {  // Slot is free
                    availableSlots[j] = true;  // Mark slot as occupied
                    maxProfit += p;  // Add profit
                    count++;  // Increase job count
                    break;  // Stop searching for slots
                }
            }
        }
        
        /* ‚úÖ Step 5: Return the Result (Jobs Count, Maximum Profit) */
        return new ArrayList<>(Arrays.asList(count, maxProfit));
    }
}
